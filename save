/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Webserv.cpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlazzare <mlazzare@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/07/31 16:09:14 by mlazzare          #+#    #+#             */
<<<<<<< HEAD
/*   Updated: 2022/08/12 19:14:09 by ablondel         ###   ########.fr       */
=======
/*   Updated: 2022/08/10 08:34:57 by mlazzare         ###   ########.fr       */
>>>>>>> 2d43557884ee6be2ec3be60f7015efff3eeeef26
/*                                                                            */
/* ************************************************************************** */

# include "../inc/Webserv.hpp"

<<<<<<< HEAD
std::vector<ServerInfo>&     Webserv::getServers()       {   return _servers;  };
std::vector<int>&            Webserv::getPorts()        {   return _ports;  };

// probably to refactor
bool        Webserv::isCGI_request(std::string html_content)
{
    std::string root = "/home/user42/webserv/cgi-bin/";                 // hardcoded here; this should be retrieved from ServerInfo > page > root
    size_t pos = html_content.find("action");
    if (pos == std::string::npos)
        {   std::cout << "Invalid action for CGI\n"; return false;              };
    pos += 7;                                                           // action="........", we want to start from the first \", ie pos + 7
    std::string action;
    while ( html_content[++pos] != '\0'
        && html_content[pos] != '\"')
        action += html_content[pos];
    size_t extension = action.size() - 3;
    if (action.compare(extension, action.size(), ".py")                 // check if it's a pyhton or perl script [ is this necessary ? ]
        && action.compare(extension, action.size(), ".pl"))
        {   std::cout << "Invalid file extension for CGI\n"; return false;      };
    pos = html_content.find("method");
    if (pos == std::string::npos)
        {   std::cout << "Invalid method for CGI\n"; return false;              };
    pos += 7;                                                           // method="........", we want to start from the first \", ie pos + 7
    std::string method;
    while ( html_content[++pos] != '\0'
        && html_content[pos] != '\"')
        method += html_content[pos];
    if (method.compare("get") != 0                                      // only method get and post are accepted for cgi
        && method.compare("post") != 0)
        {   std::cout << "Invalid method for CGI\n"; return false;              };
    root += action;
    if (access(root.c_str(), X_OK) < 0)                                 // if executable exist and it's executable
        {   std::cout << "File not executable by CGI\n"; return false;          };
    return true;
=======
Webserv::Webserv()
{
    return ;
>>>>>>> 2d43557884ee6be2ec3be60f7015efff3eeeef26
}

Webserv::Webserv(std::vector<ServerInfo> &s) : _servers(s)
{
<<<<<<< HEAD
=======
    std::vector<int> tmp(s.size());
    _sockets = tmp;
>>>>>>> 2d43557884ee6be2ec3be60f7015efff3eeeef26
    for (std::vector<ServerInfo>::iterator it = _servers.begin(); it != _servers.end(); it++)
    {
        log(GREEN, "SERVER NAME = ", it->getServerName());
        log(GREEN, "SERVER PORT = ", it->getPort());
        log(GREEN, "MAX CLIENT BODY = ", it->getClientMaxBodySize());
        log(GREEN, "ROOT = ", it->getServerRoot());
        log(GREEN, "INDEX = ", it->getServerIndex());
        std::vector<page> current_pages = it->getPages();
        _ports.push_back(it->getPort());
<<<<<<< HEAD
        log(RED, "----------------------------------------------------------", 0);
    }
    _size = _ports.size();
    _sockets.resize(_size);
    _addrs.resize(_size);
=======
        //for (std::vector<page>::iterator it = current_pages.begin(); it != current_pages.end(); it++)
        //{
        //    log(GREEN, "location = ", it->location_path);
        //    for (std::vector<std::string>::iterator rit = it->methods.begin(); rit != it->methods.end(); rit++)
        //        log(GREEN, "ALLOWED METHOD = ", *rit);
        //    log(GREEN, "autoindex = ", it->autoindex);
        //    log(GREEN, "is CGI = ", it->is_cgi);
        //}
        log(RED, "----------------------------------------------------------", 0);
    }
>>>>>>> 2d43557884ee6be2ec3be60f7015efff3eeeef26
    return ;
}

Webserv::~Webserv()
<<<<<<< HEAD
=======
{
    return ;
}

void    Webserv::close_all(std::vector<int> &sockets)
>>>>>>> 2d43557884ee6be2ec3be60f7015efff3eeeef26
{
    return ;
}

void    Webserv::close_all()
{
    for (std::vector<int>::iterator it = _sockets.begin(); it != _sockets.end(); it++)
        close(*(it));
}

int     Webserv::set_server()
{
    int on = 1;
    for (size_t i = 0; i != _ports.size(); i++)
    {
        if ((_sockets[i] = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        {
            close_all();
            return -1;
        }
        if (fcntl(_sockets[i], F_SETFL, O_NONBLOCK) < 0)
        {
            close_all();
            return -2;
        }
        if (setsockopt(_sockets[i], SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0)
        {
            close_all();
            return -3;
        }
        memset(&_addrs[i], 0, sizeof(_addrs[i]));
        _addrs[i].sin_family = AF_INET;
        _addrs[i].sin_addr.s_addr = inet_addr("127.0.0.1");
        _addrs[i].sin_port = htons(_ports[i]);
        if ((bind(_sockets[i], (struct sockaddr *)&_addrs[i], sizeof(_addrs[i]))) < 0)
        {
            close_all();
            return -4;
        }
        if ((listen(_sockets[i], BACKLOG) < 0))
        {
            close_all();
            return -5;
        }
    }
    return 0;
}



void    Webserv::accept_clients()
{
    for (int i = 0; i < _max; i++)
    {
        if (FD_ISSET(_sockets[i], &_read_set))
        {
            socklen_t len = sizeof(sockaddr[i]);
            _connection = accept(_sockets[i], (struct sockaddr*)&_addrs[i], &len);
            if (_connection < 0)
                close_all();
            FD_SET(_connection, &_current_set);
            _clients.push_back(_connection);
            if (_connection >= _max)
                _max = _connection;
            break ;
        }
    }
}

void    Webserv::parse_request(std::string &request)
{
    size_t pos = 0;
    std::string res;
    if (!request.length())
        return ;
    while ((pos = request.find('\n')) != std::string::npos)
    {
        res = request.substr(0, pos);
        request.erase(0, pos + 1);
        std::cout << "|" << res << "|" << std::endl;
    }
}

void    Webserv::transmit_data()
{
    int rd = 0;
    int rw = 0;
    char buffer[1024];
    /////////////////////////////////////DATA TESTS
    std::string ok = "HTTP/1.1 200\r\n\r\n";
    std::string index;
    std::ifstream ifs;
    ifs.open("./pages/website1/index.html", std::fstream::in);
    while(ifs.read(buffer, sizeof(buffer)))
        index.append(buffer, sizeof(buffer));
    index.append(buffer, ifs.gcount());
    ok.append(index);
    /////////////////////////////////////////
    for (std::vector<int>::iterator it = _clients.begin(); it != _clients.end(); it++)
    {
        bzero(&buffer, sizeof(buffer)); /* Clear the buffer */
        rd = recv(*it, buffer, sizeof(buffer), 0);
        //std::string request(buffer);
        //log(RED, "request contains: ", request);
        //if (request.length() > 0)
        //    printf("\x1B[32m[[DATA RECEIVED]]\x1B[0m\n\n%s", request.c_str());
        //parse_request(request);
        //request.clear();
        if (rd < 0)
        {
            break ;
        }
        if (rd == 0)
        {
            break ;
        }
        rw = send(*it, ok.c_str(), ok.size(), 0);
        if (rw < 0)
        {
            break ;
        }
        if (rw == 0)
        {
            break ;
        }
        close(*it);
        FD_CLR(*it, &_current_set);
        _clients.erase(it);
    }
}

int     Webserv::run_server()
{
    struct timeval timeout;
    char buffer[1024];
    int end_server;
    int rc;
    
    end_server = false;
    rc = set_server();
    if (rc < 0)
        return -1;
    FD_ZERO(&_current_set);
    _max = _sockets.back();
    for (std::vector<int>::iterator it = _sockets.begin(); it != _sockets.end(); it++)
        FD_SET(*it, &_current_set);
    while (end_server == false)
    {
        FD_ZERO(&_read_set);
        timeout.tv_usec = 0;
        timeout.tv_sec = 3 * 60;
        _read_set = _current_set;
        rc = select(_max + 1, &_read_set, NULL, NULL, &timeout);
        if (rc < 0) // select() error
        {
            close_all();
            end_server = true;
            break ;
        }
        if (rc == 0) // select() timeout
        {
            close_all();
            end_server = true;
            break ;
        }
        transmit_data();
        accept_clients();
    }
    close_all();
    return 0;
}

<<<<<<< HEAD
=======
std::vector<ServerInfo>&     Webserv::getServers()       {   return _servers;    };
std::vector<int>&            Webserv::getPorts()        {   return _ports;  };
>>>>>>> 2d43557884ee6be2ec3be60f7015efff3eeeef26




////////////////////////////////////////////////////////////////////////////////////////////////////////////




/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlazzare <mlazzare@student.s19.be>         +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/07/12 20:39:03 by mlazzare          #+#    #+#             */
<<<<<<< HEAD
/*   Updated: 2022/08/12 17:09:18 by ablondel         ###   ########.fr       */
=======
/*   Updated: 2022/08/11 16:13:41 by mlazzare         ###   ########.fr       */
>>>>>>> 2d43557884ee6be2ec3be60f7015efff3eeeef26
/*                                                                            */
/* ************************************************************************** */

# include "../inc/Webserv.hpp"
# include "../inc/Cgi.hpp"
# include "../inc/Config.hpp"
# include "../inc/ServerInfo.hpp"

int main(int argc, char **args, char **envp)
{
    Config  config;

    if (argc != 2)
    {
        std::cout << "Please provide ONE argument only\nUsage: ./webserv [configuration file]\n";
        return EXIT_FAILURE;
    }
    if (config.read(args[1], envp))
    {
        // Cgi     CGI;

        // std::fstream file2test;
        // std::string pwd = getenv("PWD");
        // file2test.open(pwd + "/pages/website1/hello.html", std::fstream::in | std::fstream::out | std::fstream::app);
        // std::string html_content;
        // std::string line;
        // file2test.seekg(0); // only for mac
        // while (getline(file2test, line))
        //     html_content.append(line);
        // file2test.close();
        // std::cout << "Webserv class starts here\n";
        // if (CGI.isCGI_request(html_content))
        // {    std::cout << "Ready4CGI\n";  CGI.exec_CGI(CGI.get_CGIrequest());       };
        Webserv webserv(config.getServers());
        webserv.run_server();
        //return EXIT_SUCCESS;
        /*
        Add function to get ports from config into a vector
        Now its done in the constructor above.
        */
        size_t size = webserv.getPorts().size();
        std::vector<int> sockets(size);
        std::vector<struct sockaddr_in> addrs;//(size);
        webserv.run_server(addrs);
        
        // return EXIT_SUCCESS;
    }
    return EXIT_FAILURE;
}


