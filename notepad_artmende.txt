Webserv.cpp at line 141 : unhandled exception

        checking_for_new_clients();
        looping_through_read_set();
        looping_through_write_set();
Those 3 functions should probably be put in a try/catch block




just under it : 
buffer[bytes_recv] = 0;
std::string buf(buffer);
	We don't need to limit the buffer with \0; It might actually write outside of the array like that, and the request itself might contains \0 already
	We have to initialize the string with the lenght that we got from recv()

this constructor can be used : from sequence (5)	std::string (const char* s, size_t n);



(*it)->getRequestString().append(buffer, bytes_recv);
	Will this work with getRequestString() being const ? probably not
	Especially it returns a copy of the string stored in the class
	We should create an appender function
	Client::setRequestString() already does that. Should we specify the length to be appended ?


Client     *Webserv::accept_new_client(int listening_socket)
	Make this function take a Server as a parameter instead. No need to then find the server matching the socket
	Also in that function : nullptr is c++11






Webserv::handleRequest()

Check method, URI and version.
they must exist, uri not be too long and version must be correct, and method must be 
GET, POST or DELETE

Then we simply call the function corresponding to the method

In that function, we will have to check that the method is allowed there.
Should we check that already in handleRequest() ?


	if method is GET : 
		try to open the requested file, if error with open -> error not found
		for each writing loop cycle, copy a buffer from the file and send it to the client
		keep track of how much was actually sent 


--> in GETmethod()
		Check if it is a folder or a file ? To check for autoindex or not
		After looping through page vector, what about just trying to open the URI and see if it opens or not ?


--> write_loop
		response stream associated with a client remains open. At each loop we send up to a buffer.
		strategy can be as follow :
			* if buffer is empty, fill it by reading from stream.
			* if buffer is not empty, no need to read from stream for that loop cycle.
			* try to send the whole buffer to the Client
			* With the return of send(), we can see if the whole buffer was sent, or just a part of it.
			* if the whole buffer was sent, make it empty
			* if only a part was sent, move the data to leave only in the buffer what still needs to be sent

			* condition to clear a client :
				- stream to send has reached eof AND buffer to send is emtpy